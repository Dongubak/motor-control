# Motor 클래스

#motor-control #api #interface

> ← [[MOC-motor-control|진입점]] / [[202602031200-ethercat-motor-control-system|시스템 개요]]

## 개요

개별 모터를 제어하기 위한 사용자 인터페이스 클래스. 명령 큐를 통해 [[202602031203-ethercat-process-loop|통신 프로세스]]와 통신한다.

## 클래스 구조

```python
class Motor:
    def __init__(self, slave_index, command_queue, shared_states, lock)

    # 설정 메서드
    def set_axis(self, axis: str)
    def set_profile_velocity(self, rpm)
    def set_profile_accel_decel(self, accel_rpm_per_sec, decel_rpm_per_sec)

    # 제어 메서드
    def set_origin(self)
    def move_to_position_mm(self, target_mm)

    # 상태 프로퍼티
    @property status_word -> int
    @property current_position_mm -> float
    def is_moving(self) -> bool
```

**위치**: `motor.py:588-662`

## 주요 기능

### 1. 축 설정

```python
motor.set_axis('z')  # 'x' 또는 'z'
```

축에 따라 mm/rev 변환 계수가 달라진다:
- **x축**: 11.9993 mm/rev
- **z축**: 5.9997 mm/rev

**참조**: `motor.py:15-16`

### 2. 속도 및 가감속 설정

```python
motor.set_profile_velocity(rpm=50)
motor.set_profile_accel_decel(accel_rpm_per_sec=50)
```

**중요**: 반드시 `bus.start()` **이전**에 호출해야 한다.

**관련**: [[202602031207-trajectory-interpolation|궤적 보간]]

### 3. 원점 설정

```python
motor.set_origin()
```

현재 위치를 원점(0mm)으로 설정한다. 내부적으로 현재 펄스 값을 `offset`에 저장한다.

**구현**: `motor.py:218-221`

### 4. 위치 제어

```python
motor.move_to_position_mm(-50)  # -50mm로 이동
```

[[202602031208-position-control|절대 위치 제어]]를 수행한다. [[202602031204-csp-mode|CSP 모드]]에서 [[202602031207-trajectory-interpolation|S-Curve 보간]]이 자동으로 수행된다.

### 5. 상태 확인

```python
if motor.is_moving():
    print(f"현재 위치: {motor.current_position_mm:.2f}mm")
```

## Position Factor 처리

드라이버의 Position Factor가 2:1로 설정되어 있어, 모든 펄스 계산에 2를 곱한다:

```python
# motor.py:249
target_pulse_relative = int(revolutions * PULSES_PER_REVOLUTION * 2)
```

**이유**: 드라이버 내부 스케일링 보정

**참조**: `motor.py:643-649`

## 단위 변환 체계

```
mm → revolutions → pulses (driver scale)
     (mm_per_rev)   (×2)
```

**예제** (z축, -50mm):
```
-50mm ÷ 5.9997mm/rev = -8.334 rev
-8.334 rev × 8388608 pulse/rev × 2 = -139,810,672 pulse
```

## 비동기 통신 패턴

1. 사용자가 `move_to_position_mm()` 호출
2. 명령이 `command_queue`에 전달
3. [[202602031203-ethercat-process-loop|통신 프로세스]]가 큐에서 명령 읽기
4. 궤적 생성 및 실행
5. 공유 메모리(`shared_states`)로 상태 업데이트
6. 사용자가 `is_moving()`, `current_position_mm`로 상태 확인

## 디버깅 프로퍼티

```python
motor.current_position_pulse  # 절대 펄스 위치
motor.offset_pulse            # 원점 오프셋
```

**위치**: `motor.py:652-661`

## 관련 노트

- [[202602031201-ethercat-bus-class|EtherCATBus 클래스]]
- [[202602031208-position-control|위치 제어]]
- [[202602031207-trajectory-interpolation|궤적 보간]]

---

**생성일**: 2026-02-03
**태그**: #class #user-interface
